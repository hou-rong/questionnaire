/*
 * Создать таблицу "TYPES" ("ТИПЫ").
 */
CREATE TABLE CATEGORIES (
  ID SERIAL NOT NULL PRIMARY KEY,
  NAME VARCHAR NOT NULL UNIQUE
);

/*
 * Добавить запись в таблицу "TYPES" ("ТИПЫ").
 */
INSERT INTO TYPES (NAME) VALUES ('e-NPS');

/*
 * Создать таблицу "CONDITIONS" ("СОСТОЯНИЯ").
 */
CREATE TABLE CONDITIONS (
  ID SERIAL NOT NULL PRIMARY KEY,
  NAME VARCHAR NOT NULL UNIQUE
);

/*
 * Добавить запись в таблицу "TYPES" ("ТИПЫ").
 */
INSERT INTO CONDITIONS (NAME) VALUES ('Завершённый');

/*
 * Чтобы использовать функцию "uuid_generate_v4()", необходимо выполнить SQL команду.
 */
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

/*
 * Создать таблицу "SURVEYS" ("ОПРОСЫ").
 */
CREATE TABLE SURVEYS(
  ID UUID NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
  NAME VARCHAR,
  DESCRIPTION TEXT,
  CATEGORY INTEGER,
  FOREIGN KEY (CATEGORY) REFERENCES CATEGORIES (ID),
  CONDITION INTEGER NOT NULL DEFAULT 1,
  FOREIGN KEY (CONDITION) REFERENCES CONDITIONS (ID),
  MARK BOOLEAN NOT NULL DEFAULT FALSE,
  CONTROL BOOLEAN NOT NULL DEFAULT FALSE,
  START_PERIOD TIMESTAMP,
  END_PERIOD TIMESTAMP,
  CREATED_AT TIMESTAMP NOT NULL DEFAULT NOW(),
  UPDATED_AT TIMESTAMP NOT NULL DEFAULT NOW(),
  EMAIL VARCHAR,
  BLOCKED BOOLEAN NOT NULL DEFAULT FALSE
);

/*
 * Создать функцию с названием "trigger_set_timestamp".
 */
CREATE OR REPLACE FUNCTION TRIGGER_SET_TIMESTAMP() RETURNS TRIGGER AS $$
  BEGIN
    NEW.UPDATED_AT = NOW();
    RETURN NEW;
  END;
$$ LANGUAGE plpgsql;

/*
 * Удалить функцию "TRIGGER_SET_TIMESTAMP".
 */
DROP FUNCTION IF EXISTS TRIGGER_SET_TIMESTAMP;

/*
 * Создать триггер с названием "SET_TIMESTAMP".
 */
CREATE TRIGGER SET_TIMESTAMP
BEFORE UPDATE ON SURVEYS
FOR EACH ROW
EXECUTE PROCEDURE TRIGGER_SET_TIMESTAMP();

/*
 * Удалить триггер "SET_TIMESTAMP".
 */
DROP TRIGGER SET_TIMESTAMP ON SURVEYS;

/*
 * Создать таблицу "OPTIONS" ("ВАРИАНТЫ ОТВЕТОВ")
 */
CREATE TABLE OPTIONS (
  ID SERIAL NOT NULL PRIMARY KEY,
  TEXT TEXT NOT NULL UNIQUE
);

/*
 * Создать таблицу "WIDGETS" ("ВИДЖЕТЫ")
 */
CREATE TABLE WIDGETS (
  ID SERIAL NOT NULL PRIMARY KEY,
  NAME VARCHAR NOT NULL UNIQUE
);

/*
 * Создать таблицу "QUESTIONS" ("ВОПРОСЫ")
 */
CREATE TABLE QUESTIONS (
  ID SERIAL NOT NULL PRIMARY KEY,
  TEXT TEXT NOT NULL UNIQUE,
  WIDGET INT,
  FOREIGN KEY (WIDGET) REFERENCES WIDGETS (ID)
);

/*
 * Создать таблицу "FACTORS" ("ФАКТОРЫ").
 */
CREATE TABLE FACTORS (
  ID SERIAL NOT NULL PRIMARY KEY,
  NAME VARCHAR NOT NULL UNIQUE
);

/*
 * Создать таблицу связей между опросами и факторами.
 */
CREATE TABLE SURVEYS_FACTORS_RELATIONSHIP (
  SURVEY_ID UUID NOT NULL,
  FOREIGN KEY (SURVEY_ID) REFERENCES SURVEYS (ID),
  FACTOR_ID INT NOT NULL,
  FOREIGN KEY (FACTOR_ID) REFERENCES FACTORS (ID)
);

/*
 * Создать таблицу связей между опросами и организационной структурой
 */
CREATE TABLE SURVEYS_ORGANIZATIONS_RELATIONSHIP (
  SURVEY_ID UUID NOT NULL,
  FOREIGN KEY (SURVEY_ID) REFERENCES SURVEYS (ID),
  ORGANIZATION_ID INT NOT NULL
);

/*
 * Создать таблицу связей между факторами и вопросами.
 */
CREATE TABLE FACTORS_QUESTIONS_RELATIONSHIP (
  FACTOR_ID INT NOT NULL,
  FOREIGN KEY (FACTOR_ID) REFERENCES FACTORS (ID),
  QUESTION_ID INT NOT NULL,
  FOREIGN KEY (QUESTION_ID) REFERENCES QUESTIONS (ID)
);

/*
 * Создать таблицу связей между вопросами и вариантами ответов.
 */
CREATE TABLE QUESTIONS_OPTIONS_RELATIONSHIP (
  QUESTION_ID INT NOT NULL,
  FOREIGN KEY (QUESTION_ID) REFERENCES QUESTIONS (ID),
  OPTION_ID INT NOT NULL,
  FOREIGN KEY (OPTION_ID) REFERENCES OPTIONS (ID)
);

/*
 * Создать таблицу связей между опросами и вопросами.
 */
CREATE TABLE SURVEYS_QUESTIONS_RELATIONSHIP (
  SURVEY_ID UUID NOT NULL,
  FOREIGN KEY (SURVEY_ID) REFERENCES SURVEYS (ID),
  QUESTION_ID INT NOT NULL,
  FOREIGN KEY (QUESTION_ID) REFERENCES QUESTIONS (ID)
);

/*
 * Создать связь между опросами и сотрудниками.
 */
CREATE TABLE SURVEYS_EMPLOYEES_RELATIONSHIP (
  SURVEY_ID UUID NOT NULL,
  FOREIGN KEY (SURVEY_ID) REFERENCES SURVEYS (ID),
  EMPLOYEE VARCHAR NOT NULL,
  STATUS BOOLEAN NOT NULL DEFAULT FALSE
);

/*
 * Создать триггер отслеживающий изменения в таблице "SURVEYS".
 */
CREATE TRIGGER check_for_updates_in_surveys
BEFORE UPDATE ON SURVEYS
FOR EACH ROW
WHEN (OLD.UPDATED_AT IS DISTINCT FROM NEW.UPDATED_AT)
EXECUTE PROCEDURE CREATE_SURVEYS_QUESTIONS_RELATIONSHIP();

/*
 * Удаление триггера "CHECK_FOR_UPDATES_IN_SURVEYS" в таблице "SURVEYS".
 */
DROP TRIGGER check_for_updates_in_surveys ON SURVEYS;

/*
 * Создать функцию для создания записей в таблице "SURVEYS_QUESTIONS_RELATIONSHIP".
 */
CREATE OR REPLACE FUNCTION CREATE_SURVEYS_QUESTIONS_RELATIONSHIP() RETURNS TRIGGER AS $FUNCTION$
  BEGIN
    DELETE FROM SURVEYS_QUESTIONS_RELATIONSHIP WHERE SURVEY_ID = NEW.ID;
    INSERT INTO SURVEYS_QUESTIONS_RELATIONSHIP (SURVEY_ID, QUESTION_ID)
    SELECT NEW.ID SURVEY_ID, QUESTION_ID
    FROM FACTORS_QUESTIONS_RELATIONSHIP
    WHERE FACTOR_ID IN (
      SELECT FACTOR_ID FROM SURVEYS_FACTORS_RELATIONSHIP
      WHERE SURVEY_ID = NEW.ID
    );
    RETURN NEW;
  END;
$FUNCTION$ LANGUAGE plpgsql;

/*
 * Создать процедуру для проверки актуальности состояния и статуса блокировки в таблице "SURVEYS".
 */
CREATE OR REPLACE PROCEDURE tracker(CUSTOM_TIME TIMESTAMP WITHOUT TIME ZONE) AS $FUNCTION$
BEGIN
  UPDATE SURVEYS SET CONDITION = 3 WHERE CONDITION = 2 AND START_PERIOD IS NOT NULL AND END_PERIOD IS NOT NULL AND CUSTOM_TIME > END_PERIOD;
  UPDATE SURVEYS SET BLOCKED = TRUE WHERE CONDITION = 2 AND START_PERIOD IS NOT NULL AND END_PERIOD IS NOT NULL AND CUSTOM_TIME BETWEEN START_PERIOD AND END_PERIOD;
END;
$FUNCTION$ LANGUAGE plpgsql;

/*
 * Удалить процедуру "tracker".
 */
DROP PROCEDURE IF EXISTS tracker(TIMESTAMP);

/*
 * Вызов процедуры "tracker".
 */
CALL tracker('2019-03-29 16:37:00');

/*
 * Создать UNIQUE CONSTRAINT для таблицы "SURVEYS_EMPLOYEES_RELATIONSHIP".
 */
ALTER TABLE SURVEYS_EMPLOYEES_RELATIONSHIP ADD CONSTRAINT unique_key UNIQUE (SURVEY_ID, EMPLOYEE);

/*
 * Создать процедуру для создания актуальных (динамичных) данных в таблице "SURVEYS_EMPLOYEES_RELATIONSHIP".
 */
CREATE OR REPLACE PROCEDURE creator(SURVEY_IDENTIFIER uuid, EMPLOYEES VARCHAR[]) AS $FUNCTION$
  BEGIN
    DELETE FROM SURVEYS_EMPLOYEES_RELATIONSHIP
    WHERE SURVEY_ID = SURVEY_IDENTIFIER
    AND EMPLOYEE <> ALL (EMPLOYEES);
    INSERT INTO SURVEYS_EMPLOYEES_RELATIONSHIP (SURVEY_ID, EMPLOYEE)
    SELECT SURVEY_IDENTIFIER SURVEY_ID, EMPLOYEE FROM UNNEST(ARRAY[EMPLOYEES]) EMPLOYEE
    ON CONFLICT ON CONSTRAINT unique_key
    DO NOTHING;
  END;
$FUNCTION$ LANGUAGE plpgsql;

/*
 * Удалить процедуру "creator".
 */
DROP PROCEDURE IF EXISTS creator(uuid, varchar[]);

/*
 * Вызов процедуры "creator".
 */
CALL creator('99c89a24-fff2-4cbc-a542-b1e956a352f9', ARRAY['NNogerbek@beeline.kz']);

/*
 * Создать таблицу для email шаблонов.
 */
CREATE TABLE TEMPLATES (
  ID SERIAL NOT NULL PRIMARY KEY,
  TEMPLATE TEXT NOT NULL
);

/*
 * Удалить из таблицы "SURVEYS_FACTORS_RELATIONSHIP" constraint.
 */
ALTER TABLE SURVEYS_FACTORS_RELATIONSHIP DROP CONSTRAINT surveys_factors_relationship_survey_id_fkey;

/*
 * Добавить первичный ключ в таблицу "SURVEYS_FACTORS_RELATIONSHIP" с каскадным удалением.
 */
ALTER TABLE SURVEYS_FACTORS_RELATIONSHIP
ADD CONSTRAINT surveys_factors_relationship_survey_id_fkey
FOREIGN KEY (SURVEY_ID)
REFERENCES SURVEYS(ID)
ON DELETE CASCADE;

/*
 * Удалить из таблицы "SURVEYS_ORGANIZATIONS_RELATIONSHIP" constraint.
 */
ALTER TABLE SURVEYS_ORGANIZATIONS_RELATIONSHIP DROP CONSTRAINT surveys_organizations_relationship_survey_id_fkey;

/*
 * Добавить первичный ключ в таблицу "SURVEYS_ORGANIZATIONS_RELATIONSHIP" с каскадным удалением.
 */
ALTER TABLE SURVEYS_ORGANIZATIONS_RELATIONSHIP
ADD CONSTRAINT surveys_organizations_relationship_survey_id_fkey
FOREIGN KEY (SURVEY_ID)
REFERENCES SURVEYS(ID)
ON DELETE CASCADE;

/*
 * Удалить из таблицы "SURVEYS_ORGANIZATIONS_RELATIONSHIP" constraint.
 */
ALTER TABLE SURVEYS_QUESTIONS_RELATIONSHIP DROP CONSTRAINT surveys_questions_relationship_survey_id_fkey;

/*
 * Добавить первичный ключ в таблицу "SURVEYS_QUESTIONS_RELATIONSHIP" с каскадным удалением.
 */
ALTER TABLE SURVEYS_QUESTIONS_RELATIONSHIP
ADD CONSTRAINT surveys_questions_relationship_survey_id_fkey
FOREIGN KEY (SURVEY_ID)
REFERENCES SURVEYS(ID)
ON DELETE CASCADE;
